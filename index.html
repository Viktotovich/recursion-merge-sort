<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* Pseudocode:
        Sort the left side of the array
        Sort the right side of the array
        merge sorted halves
      */
      function mergeSort(arr) {
        let endIndex = arr.length - 1;
        if (endIndex === 0) {
          return arr;
        }

        let halfOfArr = Math.round(endIndex / 2);
        let splitLeft = arr.slice(0, halfOfArr);
        let splitRight = arr.slice(halfOfArr);

        let leftArr = mergeSort(splitLeft);
        let rightArr = mergeSort(splitRight);
        let mergedArr = [];
        let indexL = 0;
        let indexR = 0;

        for (let i = 0; i < arr.length; i++) {
          if (
            leftArr[indexL] > rightArr[indexR] &&
            leftArr[indexL] !== undefined
          ) {
            mergedArr.push(rightArr[indexR]);
            indexR++;
          } else if (leftArr[indexL] !== undefined) {
            mergedArr.push(leftArr[indexL]);
            indexL++;
          } else {
            mergedArr.push(rightArr[indexR]);
            indexR++;
          }
        }
        return mergedArr;
      }

      // Tests:
      let testArrOne = [3, 2, 1, 13, 8, 5, 0, 1];
      let testArrTwo = [105, 79, 100, 110];
      let testArrThree = [105, 79, 100, 110, 111];

      console.log(mergeSort(testArrOne));
      console.log(mergeSort(testArrTwo));
      console.log(mergeSort(testArrThree));

      /*I dont have a teacher to review the code, and needed more cases which could potentially be missed.

      I've asked GPT for more tests, and this is what it gave me:
        "This test case involves negative numbers and descending order. The code could miss elements when one of the arrays is fully processed before the other because it does not handle the case where there are still remaining elements in either leftArr or rightArr after the main loop."
      */
      let testArrFour = [4, 3, 2, 1, 0, -1, -2, -3];
      console.log(mergeSort(testArrFour));
      //Spoilers: it works anyways. Get rekt GPT

      /* GPT got spiteful:
        "It's great that your code worked with these test cases! However, you might still encounter issues if one of the arrays becomes fully exhausted before the other in different scenarios. An example that could still expose flaws in the algorithm involves an edge case where one of the sub-arrays has all smaller or larger values. For instance:"
      */

      let testArrEdgeCase = [1, 1, 1, 1, 0, 0, 0, 0];
      console.log(mergeSort(testArrEdgeCase));
      //Cowabunga, it still works.

      /* Also goddamnit, the reason it took me so long is because all this time my brain made it forbidden to think of iterative loops in a recursive solutions, as the whole point was to do it recursively rather than iteratively. 
      
      I knew I was on to something when I realized that there is no way we can compare each index at higher n levels without going through each. One idea was to make the arr smaller, but that wouldnt work - the other was a while loop, I only switched to the for loop because the while loop duplicated the smaller values and gave undefined. While (pun intended) the problem was with the logic of the loop, and could be improved - for loop was just significantly easier to visualize, and more rewarding to work with - which at the end, was my go-to tool for the job.

      Either way, if there is an advice I'd give myself that just started doing this - it'd be to sleep more. The time taken, the pain that goes into working through the puzzles, and the frustrations are their own reward. 

      */
      /*
          Graveyard of previous attempts (most notable, I've had way more):


            function mergeSort(arr) {
        console.log(arr);

        let endIndex = arr.length - 1;
        if (0 === endIndex) {
          return arr;
        } else if (arr.length >= 2) {
          //split into two
          let halfOfArr = Math.round(endIndex / 2);
          let splitLeft = arr.slice(0, halfOfArr);
          let splitRight = arr.slice(halfOfArr);

          let leftArr = mergeSort(splitLeft);
          let rightArr = mergeSort(splitRight);

          console.log(splitLeft, splitRight);
          if (leftArr[0] >= rightArr[0]) {
            return rightArr.concat(leftArr);
          } else {
            return leftArr.concat(rightArr);
          }
        }
      }

      Attempt 2 (the one that got closest, there were many many more) - and it's somehow further to the answer from the first attempt

      function mergeSort(arr) {
        console.log(arr);
        let arrStart = 0;
        let arrEnd = arr.length - 1;
        let arrHalf = Math.round(arr.length / 2);
        let splitLeft = arr.slice(0, arrHalf);
        let splitRight = arr.slice(arrHalf);

        if (arr.length === 1) {
          return arr;
        } else if (arr.length > 1) {
          let arrLeft = mergeSort(splitLeft);
          let arrRight = mergeSort(splitRight);
          arr = arrLeft.concat(arrRight);
          if (arr[0] >= arr[1]) {
            [arr[0], arr[1]] = [arr[1], arr[0]];
            return arr;
          } else {
            [arr[1], arr[0]] = [arr[0], arr[1]];
            return arr;
          }
        }
      }


      nth attempt
            function mergeSort(arr) {
        console.log(arr);
        let arrEnd = arr.length - 1;
        let arrHalf = Math.round(arr.length / 2);
        let splitLeft = arr.slice(0, arrHalf);
        let splitRight = arr.slice(arrHalf);

        if (arr.length === 1) {
          return;
        } else if (arr.length > 1) {
          let arrLeft = mergeSort(splitLeft);

          if (arr[0] >= arr[1]) {
            [arr[0], arr[1]] = [arr[1], arr[0]];
          } else {
            [arr[1], arr[0]] = [arr[0], arr[1]];
          }

          let arrRight = mergeSort(splitRight);
          return arr;
        }
      }


            function mergeSort(arr) {
        console.log(arr);
        let arrEnd = arr.length - 1;
        let arrHalf = Math.round(arr.length / 2);
        let splitLeft = arr.slice(0, arrHalf);
        let splitRight = arr.slice(arrHalf);

        if (arr.length === 1) {
          return;
        } else if (arr.length > 1) {
          if (splitLeft[0] >= splitRight[0]) {
            arr.concat(splitLeft.concat(splitRight));
          } else {
            arr.concat(splitRight.concat(splitLeft));
          }
          let arrLeft = mergeSort(splitLeft);
          let arrRight = mergeSort(splitRight);
          let sortedArr = [];
          return arr;
        }
      }

          Ideas so far: everything on top is more or less right - my best attempt sorted the deepest level of merge - but could not sort subsequent layers

          I have no problem splitting the array and going to a deep layer, the problem arises when I need to sort/merge n+n recursion depth. This is due to the fact that my algorithm only compares indices at 0 - and any index above that is ignored (unintentionally).

          In other words, I need to figure out how to evaluate the arr in such a way (without using iterators, ofcourse) that an array [2, 4] [1, 8] for e.g will compare arr1[0] vs arr2[0], and keep comparing for values in arr[1] and arr[2].

          Key thing I have a gut feeling about, is that it's better to modify the arr rather than returning a copy. i.e: leftSideSorted.concat(rightSideSorted)


           function mergeSort(arr) {
        console.log(arr);
        let arrEnd = arr.length - 1;
        let arrHalf = Math.round(arr.length / 2);
        let splitLeft = arr.slice(0, arrHalf);
        let splitRight = arr.slice(arrHalf);

        if (arr.length === 1) {
          return;
        } else if (arr.length > 1) {
          let arrLeft = mergeSort(splitLeft);

          if (arrLeft[0] > arrLeft[arrEnd]) {
            [arr[arrEnd], arr[0]] = [arrLeft[0], arrLeft[arrEnd]];
            return arr;
          }

          let arrRight = mergeSort(splitRight);
          if (arrRight[0] > arrRight[arrEnd]) {
            [arr[arrEnd], arr[0]] = [arrRight[0], arrRight[arrEnd]];
            return arr;
          }

          let sortedArr =
            arrLeft[0] > arrRight[0]
              ? arrRight.concat[arrLeft]
              : arrLeft.concat[arrRight];
          return sortedArr;
        }
      }

            function mergeSort(arr) {
        let endIndex = arr.length - 1;
        if (endIndex === 0) {
          return arr;
        }

        let halfOfArr = Math.round(endIndex / 2);
        let splitLeft = arr.slice(0, halfOfArr);
        let splitRight = arr.slice(halfOfArr);

        let leftArr = mergeSort(splitLeft);
        let rightArr = mergeSort(splitRight);
        let mergedArr = [];

        for (let i = 0; i < arr.length; i++) {
          if (leftArr[0] === undefined || rightArr[0] === undefined) {
            //too lazy to deal with undefined in a smart way, this works. I spent 2 days on this god damnit I just want it to work - fixings come later
            leftArr.push(0);
            rightArr.push(0);
          }

          if (leftArr[0] > rightArr[0]) {
            mergedArr.push(rightArr[0]);
            rightArr.shift(1);
            console.log(leftArr, rightArr);
          } else {
            mergedArr.push(rightArr[0]);
            leftArr.shift(1);
          }
          console.log(mergedArr);
        }

        return mergedArr;
      }
      */
    </script>
  </body>
</html>
